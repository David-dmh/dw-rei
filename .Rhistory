print("loaded something")
}
try(
load_attempt <- read.csv("nothing")
)
if(exists(load_attempt)){
print("loaded something")
}else{
print("nothing found")
}
try(
load_attempt <- read.csv("nothing.csv")
)
if(exists(load_attempt)){
print("loaded something")
}else{
print("nothing found")
}
if(file.exists("geocoded_loc_ref.csv")){
print("File is there")
}else{
print("Nothing found")
}
if(~file.exists("geocoded_loc_ref.csv")){
print("No cache")
}else{
print("Cache exists")
}
if(!file.exists("geocoded_loc_ref.csv")){
print("No cache")
}else{
print("Cache exists")
}
if(! file.exists("geocoded_loc_ref.csv")){
print("No cache")
}else{
print("Cache exists")
}
if(!file.exists("geocoded_loc_ref.csv")){
# no cache - gen new cache
dimProperty_fll <- mutate_geocode(subset(dimProperty, select=c("full_address")), full_address)
colnames(dimProperty_fll) <- c("full_address", "longitude", "latitude")
# geocode failed:
sqldf("
SELECT
*
FROM
dimProperty_fll
WHERE
(longitude IS NULL AND latitude IS NULL)
;
")
# save scrape
write.csv(dimProperty_fll,
"C:/Users/User/Documents/FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/eda/geocoded_loc_ref.csv",
row.names=FALSE)
}else{
print("Cache exists, skipped step...")
}
dim(dimProperty)[1]
dim(dimProperty_fll)[1]
# to geocode includes:
# - previously failed-to-geocode records (not written to cache file)
# - new properties recently added to dimProperty
# may need to add failures to cache if always fail to geocode as this may
# cause slow processing times as the dimension grows
to_geocode <- sqldf("
SELECT
full_address
FROM
dimProperty
EXCEPT
SELECT
full_address
FROM
dimProperty_fll
;
")
to_geocode
# single run - working
df_dimProperty_fll_temp <- data.frame(to_geocode, stringsAsFactors=FALSE)
colnames(df_dimProperty_fll_temp) <- c("full_address")
df_dimProperty_fll_new <- mutate_geocode(df_dimProperty_fll_temp, full_address)
colnames(df_dimProperty_fll_new) <- c("full_address", "longitude", "latitude")
df_dimProperty_fll_new
if(exists("df_dimProperty_fll_new")){
# non-empty = write
# merge with cached if above results are non-empty
dimProperty_fll_merged <- merge(x=dimProperty_fll,
y=df_dimProperty_fll_new,
by="full_address",
all=TRUE)
# reformat
skew_rows <- which(!is.na(dimProperty_fll_merged[, 4]))
# shift .y's left
if(length(skew_rows) != 0){
for(i in skew_rows){
dimProperty_fll_merged[i, 2:3] <- dimProperty_fll_merged[i, 4:5]
}
}
colnames(dimProperty_fll_merged)[2:3] <- c("longitude", "latitude")
# discard old columnns
dimProperty_fll_merged <- subset(dimProperty_fll_merged,
select=c("full_address", "longitude", "latitude"))
# # update cache
write.csv(
dimProperty_fll_merged,"C:/Users/User/Documents/FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/eda/geocoded_loc_ref.csv",
row.names=FALSE)
# view new
dimProperty_fll_merged
} else {
print("No new geocoded data, not updating cache")
}
# this data ready for analysis, just need to exclude nulls (if applicable) for plot
df <- read.csv("geocoded_loc_ref.csv")
df
# remove nulls (if blanks in cache)
df <- sqldf("
SELECT
*
FROM
df
WHERE
(longitude IS NOT NULL OR latitude IS NOT NULL)
AND
(latitude < -10.360438)
AND
(latitude < -10.360438)
AND
(latitude > -45.599262)
AND
(longitude > 111.861226)
AND
(longitude < 155.542866)
;
")
df
# AU
# UB and LB = -10.360438 <-> -45.599262 (latitude range)
# LB and RB = 111.861226 <-> 155.542866 (longitude range)
# check that the geocoding done correctly with mapview
locations_sf <- st_as_sf(df,
coords=c("longitude", "latitude"),
crs=4326)
locations_sf
mapview(locations_sf)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(Rcpp)
library(plyr)
library(RPostgres)
library(DBI)
library(tidyverse)
library(ggmap)
library(sqldf)
library(sf)
library(mapview)
# ?register_google
register_google(key=Sys.getenv("Google_Maps_Platform_API_Key"))
con <- dbConnect(RPostgres::Postgres(),
host="localhost",
port="5432",
dbname="REI_Prod",
user="postgres",
password=rstudioapi::askForPassword("Database password"))
# dbExistsTable(con, "factListings")
# df_factListings <- dbGetQuery(con, "
#
# SELECT
# *
# FROM
# public.\"factListings\"
# ;
#
# ")
dimProperty <- dbGetQuery(con, "
SELECT
*
FROM
public.\"dimProperty\"
;
")
dimProperty
dimProperty_fll <- read.csv("geocoded_loc_ref.csv")
dimProperty_fll
if(!file.exists("geocoded_loc_ref.csv")){
# no cache - gen new cache
dimProperty_fll <- mutate_geocode(subset(dimProperty, select=c("full_address")), full_address)
colnames(dimProperty_fll) <- c("full_address", "longitude", "latitude")
# geocode failed:
sqldf("
SELECT
*
FROM
dimProperty_fll
WHERE
(longitude IS NULL AND latitude IS NULL)
;
")
# save scrape
write.csv(dimProperty_fll,
"C:/Users/User/Documents/FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/eda/geocoded_loc_ref.csv",
row.names=FALSE)
}else{
print("Cache exists, skipped step...")
}
dim(dimProperty)[1]
dim(dimProperty_fll)[1]
# to geocode includes:
# - previously failed-to-geocode records (not written to cache file)
# - new properties recently added to dimProperty
# may need to add failures to cache if always fail to geocode as this may
# cause slow processing times as the dimension grows
to_geocode <- sqldf("
SELECT
full_address
FROM
dimProperty
EXCEPT
SELECT
full_address
FROM
dimProperty_fll
;
")
to_geocode
# to geocode includes:
# - previously failed-to-geocode records (not written to cache file)
# - new properties recently added to dimProperty
# may need to add failures to cache if always fail to geocode as this may
# cause slow processing times as the dimension grows
to_geocode <- sqldf("
SELECT
full_address
FROM
dimProperty
EXCEPT
SELECT
full_address
FROM
dimProperty_fll
;
")
to_geocode
# single run - working
df_dimProperty_fll_temp <- data.frame(to_geocode, stringsAsFactors=FALSE)
colnames(df_dimProperty_fll_temp) <- c("full_address")
df_dimProperty_fll_new <- mutate_geocode(df_dimProperty_fll_temp, full_address)
to_geocode.empty
dim(to_geocode)
dim(to_geocode)[1]
if(dim(to_geocode)[1]) = 0
if(dim(to_geocode)[1]) == 0
if(dim(to_geocode)[1]) == 0{
if(dim(to_geocode)[1] = 0){
if(dim(to_geocode)[1] == 0){
print("0")
}
if(dim(to_geocode)[1] != 0){
print("0")
}
if(dim(to_geocode)[1] != 0){
# single run - working
df_dimProperty_fll_temp <- data.frame(to_geocode, stringsAsFactors=FALSE)
colnames(df_dimProperty_fll_temp) <- c("full_address")
df_dimProperty_fll_new <- mutate_geocode(df_dimProperty_fll_temp, full_address)
colnames(df_dimProperty_fll_new) <- c("full_address", "longitude", "latitude")
df_dimProperty_fll_new
}
if(exists("df_dimProperty_fll_new")){
# non-empty = write
# merge with cached if above results are non-empty
dimProperty_fll_merged <- merge(x=dimProperty_fll,
y=df_dimProperty_fll_new,
by="full_address",
all=TRUE)
# reformat
skew_rows <- which(!is.na(dimProperty_fll_merged[, 4]))
# shift .y's left
if(length(skew_rows) != 0){
for(i in skew_rows){
dimProperty_fll_merged[i, 2:3] <- dimProperty_fll_merged[i, 4:5]
}
}
colnames(dimProperty_fll_merged)[2:3] <- c("longitude", "latitude")
# discard old columnns
dimProperty_fll_merged <- subset(dimProperty_fll_merged,
select=c("full_address", "longitude", "latitude"))
# # update cache
write.csv(
dimProperty_fll_merged,"C:/Users/User/Documents/FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/eda/geocoded_loc_ref.csv",
row.names=FALSE)
# view new
dimProperty_fll_merged
} else {
print("No new geocoded data, not updating cache")
}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(Rcpp)
library(plyr)
library(RPostgres)
library(DBI)
library(tidyverse)
library(ggmap)
library(sqldf)
library(sf)
library(mapview)
# ?register_google
register_google(key=Sys.getenv("Google_Maps_Platform_API_Key"))
con <- dbConnect(RPostgres::Postgres(),
host="localhost",
port="5432",
dbname="REI_Prod",
user="postgres",
password=rstudioapi::askForPassword("Database password"))
# dbExistsTable(con, "factListings")
# df_factListings <- dbGetQuery(con, "
#
# SELECT
# *
# FROM
# public.\"factListings\"
# ;
#
# ")
dimProperty <- dbGetQuery(con, "
SELECT
*
FROM
public.\"dimProperty\"
;
")
dimProperty
dimProperty_fll <- read.csv("geocoded_loc_ref.csv")
dimProperty_fll
if(!file.exists("geocoded_loc_ref.csv")){
# no cache - gen new cache
dimProperty_fll <- mutate_geocode(subset(dimProperty, select=c("full_address")), full_address)
colnames(dimProperty_fll) <- c("full_address", "longitude", "latitude")
# geocode failed:
sqldf("
SELECT
*
FROM
dimProperty_fll
WHERE
(longitude IS NULL AND latitude IS NULL)
;
")
# save scrape
write.csv(dimProperty_fll,
"C:/Users/User/Documents/FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/eda/geocoded_loc_ref.csv",
row.names=FALSE)
}else{
print("Cache exists, skipped step...")
}
dim(dimProperty)[1]
dim(dimProperty_fll)[1]
# to geocode includes:
# - previously failed-to-geocode records (not written to cache file)
# - new properties recently added to dimProperty
# may need to add failures to cache if always fail to geocode as this may
# cause slow processing times as the dimension grows
to_geocode <- sqldf("
SELECT
full_address
FROM
dimProperty
EXCEPT
SELECT
full_address
FROM
dimProperty_fll
;
")
to_geocode
if(dim(to_geocode)[1] != 0){
# single run - working
df_dimProperty_fll_temp <- data.frame(to_geocode, stringsAsFactors=FALSE)
colnames(df_dimProperty_fll_temp) <- c("full_address")
df_dimProperty_fll_new <- mutate_geocode(df_dimProperty_fll_temp, full_address)
colnames(df_dimProperty_fll_new) <- c("full_address", "longitude", "latitude")
df_dimProperty_fll_new
}
if(exists("df_dimProperty_fll_new")){
# non-empty = write
# merge with cached if above results are non-empty
dimProperty_fll_merged <- merge(x=dimProperty_fll,
y=df_dimProperty_fll_new,
by="full_address",
all=TRUE)
# reformat
skew_rows <- which(!is.na(dimProperty_fll_merged[, 4]))
# shift .y's left
if(length(skew_rows) != 0){
for(i in skew_rows){
dimProperty_fll_merged[i, 2:3] <- dimProperty_fll_merged[i, 4:5]
}
}
colnames(dimProperty_fll_merged)[2:3] <- c("longitude", "latitude")
# discard old columnns
dimProperty_fll_merged <- subset(dimProperty_fll_merged,
select=c("full_address", "longitude", "latitude"))
# # update cache
write.csv(
dimProperty_fll_merged,"C:/Users/User/Documents/FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/eda/geocoded_loc_ref.csv",
row.names=FALSE)
# view new
dimProperty_fll_merged
} else {
print("No new geocoded data, not updating cache")
}
# this data ready for analysis, just need to exclude nulls (if applicable) for plot
df <- read.csv("geocoded_loc_ref.csv")
df
# remove nulls (if blanks in cache)
df <- sqldf("
SELECT
*
FROM
df
WHERE
(longitude IS NOT NULL OR latitude IS NOT NULL)
AND
(latitude < -10.360438)
AND
(latitude < -10.360438)
AND
(latitude > -45.599262)
AND
(longitude > 111.861226)
AND
(longitude < 155.542866)
;
")
df
# AU
# UB and LB = -10.360438 <-> -45.599262 (latitude range)
# LB and RB = 111.861226 <-> 155.542866 (longitude range)
# check that the geocoding done correctly with mapview
locations_sf <- st_as_sf(df,
coords=c("longitude", "latitude"),
crs=4326)
locations_sf
mapview(locations_sf)
cls
cls
cat("\014")
cls
cat("\014")
install.packages("dashboardthemes")
shiny::runApp('FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/app')
runApp('FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/app')
install.packages(c("dashboardthemes", "mapview", "RPostgres", "shiny", "shinydashboard", "shinythemes"))
runApp('FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/app')
runApp('FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/app')
install.packages("shinydashboard")
install.packages("shinydashboard")
runApp('FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2/app')
ls
setwd("~/FINANCES_CAREER/ONLINE_BUSINESS/Backend_API_v2")
renv::snapshot()
runApp('app')
runApp()
runApp()
install.packages("shinydashboard")
install.packages("mapview")
install.packages("RPostgres", "dashboardthemes", "shinythemes")
fld
cls
install.packages("RPostgres", "dashboardthemes", "shinythemes")
cls
install.packages("RPostgres")
install.packages("dashboardthemes")
install.packages("shinythemes")
runApp()
shiny::runApp()
getwd()
runApp()
Sys.getenv("dw-rei")
Sys.setenv("dw-rei"="C:/Users/dvdma/Documents/Projects/dw-rei")
renv::status()
renv::snapshot()
Sys.setenv("REI_Prod_password"="690151")
renv::snapshot()
renv::status()
runApp()
ls
cls
renv::activate()
shiny::runApp()
renv::status()
Sys.setenv("Google_Maps_Platform_API_Key" = "AIzaSyCQAFyy5SeIcnlBfzewaUxiHZ3P48Pa-ek")
renv::status()
renv::snapshot()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
install.packages("shinyBS")
renv::snapshot()
renv::status()
cls
cls
runApp()
runApp()
runApp()
